//静态结构体

/*
aardio 中的结构体默认为动态结构体，
在与静态接口函数交互时，动态结构体动态分配内存指针，
动态结构体的内存指针仅在调用时临时有效，并且会动态变动地址。
静态结构体拥有稳定不变的内存指针，但每次读写静态结构体的直接成员（不包含成员的成员）都会有内存同步过程。
*/
import console; 
import raw.struct;

//创建静态结构体类型,也可以在第 2 个参数中指定内存指针
var floatArray = raw.struct({
	float v[500] 
})

/*
静态结构体可直接传入其他线程使用，传入其他线程后指针地址也不会变动。
静态结构体的生命周期也由创建该静态结构体的线程维护，其他调用线程不检查指针有效性。
多线程可同时读写静态结构体，如果有必要请自行调用 thread.lock 添加线程锁。
*/ 
thread.invokeAndWait( 
	function(floatArray){
		/*
		注意创建floatArray的线程负责维护该对象的生命周期，
		使用floatArray的线程不会维护或检查内存指针是否有效。
		*/
		floatArray.v = {
			//这种方式修改静态结构体，必须覆盖成员字段 floatArray.v[1] = 456 这样写是错的。
			456,2,3
		} 
		
		/*
		如果该结构体的首个成员是数组，
		也可以直接使用索引读写该数组的成员,
		这时候是直接移动指针到索引指定的内存，速度更快
		*/
		floatArray[2] = 789.1
	},floatArray //可以直接传入线程使用
)
	
/*
不建议直接用 floatArray.v[1] 这种写法，这会导致不必要的内存同步操作
*/
var array = floatArray.v
console.log("主线程获取静态结构体的值" ,array[2] );

/*
如果该结构体的首个成员是数组，
也可以直接使用索引读写该数组的成员,
这时候是直接移动指针到索引指定的内存，速度更快
*/
console.log("主线程获取静态结构体的值" ,floatArray[3] );

console.pause(true);
