import fsys;
import raw.interface;
import process.popen;
import string.cmdline;
import string.encoding;

class java{

	ctor (...){  
		if( self._jvm ){
			return self._jvm;
		}
		
		var vm = ..thread.get("_std.java.vm" )
	 	var result,jniEnv;
		if(!vm){
			if( !__jni_init__() ) {
				return null,"应用程序未包含 JAVA 运行库"; 
			}
			
			var vm_args = getInitArgs(...); 
			vm_args.nOptions = #vm_args.options.array;
			vm_args.options = ..raw.malloc( vm_args.options ); 
			
			if( vm_args.version === null )
				vm_args.version = self.version || 0x00010006/*_JNI_VERSION_1_6*/;
			
			if( vm_args.ignoreUnrecognized === null )
				vm_args.ignoreUnrecognized = 1/*_JNI_TRUE*/;
			
			result,vm,jniEnv = JNI_CreateJavaVM(null, null,vm_args);
			if (result < 0) { 
				error( "Can't create Java VM,Result:" + result,2);
				return;
			} 
			 
			this.__isMainThread = true;
			..thread.set("_std.java.vm",vm )  
		}
		else {
			this.__isMainThread = false; 
		}
		 
		
		if( !vm ) {
			error( "Can't create Java VM(2) " ,2);
		}   
		this.vm = ..raw.interface( vm,JavaVM ) 
		
		result,jniEnv = this.vm.AttachCurrentThread(); 
		if( !jniEnv ) {
			error( "Can't attach current thread to Java VM,Result:" + result,2);
		}   
		this.env = ..raw.interface(jniEnv,JNIEnv );
		this.version = this.env.GetVersion();
		jniEnv = this.env;
		
		..table.add_gc(this,
			function(){  
				if(jniEnv){
					this.vm.DetachCurrentThread();
					//this.vm.DestroyJavaVM(); 
					this.env = null;
					this.vm = null;
					jniEnv = null;
				}
			} 
		); 
  
		this._javaClasses  = { @{_weak="kv"}};
		self._jvm = this;
		this.exceptionClear = function(){
			if ( jniEnv.ExceptionCheck() == 1/*_JNI_TRUE*/ ) {
            	jniEnv.ExceptionDescribe(); //打印错误信息
        		jniEnv.ExceptionClear(); //清除异常
        		return true; 
        	} 
		}; 
		
		this.interop = ..java.class(this,"aardio.interopServices.utility"
			,this.__isMainThread ? $"~\lib\java\.interopServices\utility.class" : null ) 
		this.fieldExists = this.interop.getMethod("getFieldValue","pointer(pointer[])");
		this.getFieldValue__ = this.interop.getMethod("getFieldValue","pointer(pointer[])");
		this.setFieldValue__ = this.interop.getMethod("setFieldValue","void(pointer[])");
		this.invokeMethod__ = this.interop.getMethod("invokeMethod","pointer(pointer[])");
		this.createInstance = this.interop.getMethod("createInstance","pointer(pointer[])");
		this.objectIsNumber  = this.interop.getMethod("objectIsNumber","bool(pointer)");
		this.objectIsString = this.interop.getMethod("objectIsString","bool(pointer)");
		this.object2Number  = this.interop.getMethod("object2Number","double(pointer)");
		this.object2String = this.interop.getMethod("object2String","string(pointer)");
		this.invokeMethod = function(obj,...){
			var obj = this.invokeMethod__(obj,...);
			if( obj ) {
				if( this.objectIsString(obj) )return this.object2String(obj);
				if( this.objectIsNumber(obj) )return this.object2Number(obj);
			}
			return obj;
		}
		this.getFieldValue = function(...){
			var obj = this.getFieldValue__(...);
			if( obj ) {
				if( this.objectIsString(obj) )return this.object2String(obj);
				if( this.objectIsNumber(obj) )return this.object2Number(obj);
			}
			return obj;
		}
		this.setFieldValue = function(obj,k,v){
			this.setFieldValue__( obj,k,v );
		}
		
		this.import =  function(classPath,clssBuffer,classLoader){
			return ..java.class(this,classPath,clssBuffer,classLoader);	
		};
	};
	object = function(jInstance){
		return ..java.object(this, jInstance );
	};
	string = function(str){
		var jInstance = jniEnv.NewStringUTF((tostring(str)));
		if (!jInstance) { 
            this.exceptionClear();
            return;
		}
		return ..java.object(this, jInstance );
	};
	double = function(v){
		return this.import("java.lang.Double").createInstanceEx("void(double)",v);
	};
	float = function(v){
		return this.import("java.lang.Float").createInstanceEx("void(float)",v);
	};
	long = function(v){
		return this.import("java.lang.Long").createInstanceEx("void(long)",v);
	};
	char = function(v){
		return this.import("java.lang.Character").createInstanceEx("void(char)",v);
	};
	short = function(v){
		return this.import("java.lang.Short").createInstanceEx("void(short)",v);
	};
	int = function(v){
		return this.import("java.lang.Integer").createInstanceEx("void(int)",v);
	};
	boolean = function(v){
		return this.import("java.lang.Boolean").createInstanceEx("void(boolean)",v);
	};			
	array = function(atype,...){ 
	 	var jtype = typeNameAardio2Java(atype)
	 	
		var arr = ...
		if(type(arr)!="table" || (arr@ ? arr@._topointer) ){
			arr = {...}
		} 
		
		if( jtype == "Object" ){
			var t;
			var jarr = jniEnv.NewObjectArray( #arr,this.import("java/lang/Object")); 
			for(i=1;#arr;1){
				t = type(arr[i]);
				if(t == "string" || t == "buffer"){ 
					jniEnv.SetObjectArrayElement(jarr,i-1,this.string(arr[i]));
				}
				elseif(t == "table"){
					if(arr[i]@ && arr[i]@._topointer){
						jniEnv.SetObjectArrayElement(jarr,i-1,arr[i]);	
					}
					elseif( #(arr[i]) ) {
						if(type(arr[i][1]==="string")){ 
							jniEnv.SetObjectArrayElement(jarr,i-1,this.stringArray(arr[i]));
						}
						else { 
							jniEnv.SetObjectArrayElement(jarr,i-1,this.array("pointer",arr[i]));
						} 
					} 
					elseif( ..table.isArray(arr) || !..table.next(arr) ){
						jniEnv.SetObjectArrayElement(jarr,i-1,this.array("pointer",{}));
					}
					
				}
				elseif(t == "number"){
					jniEnv.SetObjectArrayElement(jarr,i-1,this.double(arr[i]));
				}
				elseif(t == "boolean"){
					jniEnv.SetObjectArrayElement(jarr,i-1,this.boolean(arr[i]));
				} 
			}
			return ..java.object(this,jarr);
		}
		
		var newArray = jniEnv[  ..string.format("New%sArray",jtype) ]
		var setArray = jniEnv[  ..string.format("Set%sArrayRegion",jtype) ] 
		if(! (newArray && setArray) )
			error("错误的数组类型" + atype ,2)
			
		var jarr = newArray( #arr);
		setArray(jarr,0,#arr-1,..raw.toarray( arr ,atype,"array" )) 
		return ..java.object(this,jarr);
	};
	stringArray = function(...){ 
		var jclass = this.import("java/lang/String"); 
		if(!jclass) error("查找类失败。类:java/lang/String",2);
		
		var args = ...
		if(type(args)!=type.table)
			args = {...};
		
		if(!args){
			error("参数不能为空",2);
		} 
		
		var array = jniEnv.NewObjectArray(#args, jclass );
		var jstr;
		for(i=1;#args;1){ 
			jstr = tostring( args[i] )
			jstr = this.string( args[i] );
			if(!jstr)
				error("创建字符串对象失败",2)
				 
		    jniEnv.SetObjectArrayElement(array, i-1,jstr  );
        	if ( this.exceptionClear() ) { 
            	error("创建字符串数组失败",2);
        	}

		}
		return ..java.object(this,array);

	};
	parseString = function(jstr){
		if(!jstr)return;
		var pstr = jniEnv.GetStringUTFChars(jstr, 0);
		if (!pstr) { 
            this.exceptionClear();
            return;
		}
		var len = jniEnv.GetStringUTFLength(jstr);
		var str = ..raw.tostring(pstr,1,len); 
		
		jniEnv.ReleaseStringUTFChars(jstr,pstr);
		jniEnv.DeleteLocalRef(jstr);
		return str; 
	};
	parseArray = function(atype,jarr){
		if( type(atype) != "string") error("参数一必须是字符串指定的类型名",3);
		
		if(atype=="string")
			return this.parseStringArray(jarr)
			
		var len = jniEnv.GetArrayLength(jarr)
		if(!len)  return {};
	
		var jtype = typeNameAardio2Java(atype) 
		if( jtype == "Object" ){ 
			var array = {};
			for(i=1;len;1){
				array[i] = ..java.object(this,jniEnv.GetObjectArrayElement(jarr,i-1));
			} 
			return array;
		}
		
		var getArray = jniEnv[  ..string.format("Get%sArrayRegion",jtype) ];
		if(! getArray ){ 
			jniEnv.DeleteLocalRef(jstr);
			error("错误的数组类型" + atype ,2)
		}
		
		var carr = ..raw.toarray( len ,atype,"array" );
		getArray(jarr,0,len-1,carr) 
		
		jniEnv.DeleteLocalRef(jstr);
		return carr.array;
	};
	parseStringArray = function(jarr){
		var arr = this.parseArray("pointer",jarr)
		for(k,v in arr){
			arr[k] = this.parseString(v); 
		}
		return arr;
	};
	getClassLoader = function(){ 
		if( this.version >= 0x90000/*_JNI_VERSION_9*/ ) return;
		if( this.classLoader !== null ) return this.classLoader;
		 
		var getCurrentThread = this.import("java.lang.Thread").getMethod("currentThread","java.lang.Thread()" );
		var curThread = getCurrentThread();
		var getContextClassLoader = curThread.getMethod("getContextClassLoader","java.lang.ClassLoader()" )
		var classLoader = getContextClassLoader();
		
		if( !classLoader ){ 
			var getSystemClassLoader = this.import("java.net.URLClassLoader").getMethod("getSystemClassLoader","java.lang.ClassLoader()");
			classLoader = getSystemClassLoader();
		}
		 
		var addURL;
		try{
			addURL = classLoader.getMethod( "addURL","void(java.net.URL)" );
			this.classLoader = classLoader;
		}
		if(!addURL) {
			this.classLoader = false;
			return false;
		}
		
		classLoader[["addUrl"]] = function(path){
			if(!#path) return;
			if( ! ..string.match(path,"^\w+\:\/\/") ){ 
				var shortPath = ..io.exist(path) && ..fsys.shortpath(path);   
				if( shortPath ){
					path = ..io.fullpath(path);
					if( ..fsys.isDir(path) ){
						path = ..fsys.path.addBackslash(path);
					} 
					path = "file:///" + path;
				}
				else {
					error("错误的路径",2)
				}
				
			}
			
			if( __globalClassLoadedPaths[path] ) { return; }
			__globalClassLoadedPaths[path] = true;
			
			var url = this.import( "java.net.URL").createInstanceEx("void(string)" ,path); 
			addURL(url);//该java函数有自动去重功能(但不忽略大小写) 
		};
		classLoader[["addUrls"]] = function(urls,...){
			if( type(urls) != "table" ) urls = {urls;...};
			for(i=1;#urls;1){
				owner.addUrl(urls[i]); 
			} 	
		}
		
		return classLoader; 
	};
	addClassLoaderUrl = function(...){
		var loader = this.getClassLoader();
		if(loader) return loader.addUrls(...);
		else {
			error("Java 9 以上不支持此功能",2)
		} 
	};
	reopen = function(funcName,filename){
		var outstream = this.import( "java.io.FileOutputStream")( ..io.fullpath(filename) ); 
		var printstream = this.import("java.io.PrintStream").createInstanceEx("void(java.io.OutputStream)",outstream)	 
		var reset = this.import("java.lang.System").getMethod(funcName);	
		reset(printstream);
	};
	__jvm_init__(this) and null;
}

import java.class;
import java.object;
import java.path;

namespace java{  
	encoding = "utf-8";
	
	_classPaths = {"/";"/java/";..io.fullpath( "~/java/") }
	_libPaths = {"/java/";..io.fullpath( "~/java/") }

	addClassPath = function(...){ 
		..table.push(_classPaths,...) 
	};
	addLibPath = function(...){ 
		..table.push(_libPaths,...) 
	};
	getLibPathCommand = function(...){ 
		var libPath;
		var argLp = {...};  
		for(i=1;#_libPaths){ 
			libPath = ..io.exist(_libPaths[i]);
			if(libPath)..table.push(argLp,libPath )
		}
		
		for(k,path in argLp){ 
			argLp[k] = ..fsys.shortpath(path);
		}
		return ..string.join(argLp,";" )
	};
	 
	__prepareLocalClassPaths = function(...){ 
		if( __localClassPaths ) return __localClassPaths;
		__localClassPaths  = {...};
		
		var searchJar = function(dir){
			var dir = ..io.exist(dir)
			if( dir ) {
				..table.push( __localClassPaths ,dir);
				..fsys.enum( dir, 
							"*.jar", 
							function(dir,file,fullpath,findData){ 
								if(file){  
		           					..table.push( __localClassPaths ,fullpath )
								} 
							},false //不搜索子目录
				  		); 
			}	
		} 
		for(i=1;#_classPaths){
			searchJar(_classPaths[i])
		}
		
		for(k,path in __localClassPaths ){ 
			__localClassPaths [k] = ..fsys.shortpath(path);
		}
		return __localClassPaths;
	};	
	getClassPathCommand = function( cmd ,... ){
		var args =  ..string.join( __prepareLocalClassPaths(...) ,";" )
		if( cmd ) args = cmd +  ";" + args;
		return args;
	};
 
	//__globalClassLoadedPaths = null; 
	__jvm_init__ = function(jvm){
		if( jvm.__isMainThread ){
			__globalClassLoadedPaths = __localClassPaths;
			..thread.set("_std.java.vm.loadedPaths", __globalClassLoadedPaths);
			
			if( jvm.version < 0x90000/*_JNI_VERSION_9*/ && ..io.exist("/java/") ) {
				jvm.addClassLoaderUrl("/java/");
				..fsys.enum("/java/", "*.jar",
					function(dirname,filename,fullpath){ 
						if(filename) jvm.addClassLoaderUrl(fullpath);
					},false
				);
			}
		}
		else {
			__globalClassLoadedPaths = ..thread.get("_std.java.vm.loadedPaths" );
			__localClassPaths = __prepareLocalClassPaths();
		};
	}
	
	//%JAVA_TOOL_OPTIONS%
	//-D<propertyName>=value 在程序中可以使用 System.getProperty("propertyName") 得到value的值
	getInitArgs = function(...){
		var args = ...;
		if( args[["options"]] ){ 
			return args;
		}
		
		var args = ..table.append({"-Djava.compiler=NONE";
			 ..string.fromto(getClassPathCommand( "-Djava.class.path=."),65001,0);
			 ..string.fromto( getLibPathCommand("-Djava.library.path=.") ,65001,0)
			},..string.cmdline.arguments(...));
	 
	 	if(self.encoding){
	 		..table.unshift(args,"-Dfile.encoding="+self.encoding);
	 	}
	 	 
		var vm_args = InitArgs();
		//JNI_GetDefaultInitArgs(vm_args); 
		vm_args.options = {
			struct array[] = {};
		} 
		
		for(i=1;#args;1){ 
			vm_args.options.array[i] = VmOption( args[i] ); 
		} 
		return vm_args;
	}  
	__openProcess = function(process,exeFile,args,...){
		 
		var binPath = ..java.path.jreBin();
		if(!binPath) return null,"没有找到Java运行库"; 
		
		binPath = ..fsys.joinpath(binPath,exeFile);
		if( ! ..io.exist(binPath) ) return null,"没有找到" + exeFile;

		var args,startInfo = ..string.cmdline.arguments(args,...);
		..table.unshift(args,"-Dfile.encoding="+self.encoding,"-classpath",getClassPathCommand( "%CLASSPATH%" ) ); 
		
		var prcs,err = process(binPath,args,startInfo );
		if( prcs && self.encoding){
			prcs.codepage = ..string.encoding.getCodepage(self.encoding);
		}
		return prcs,err; 
	};
	openProcess = function(...){
		return __openProcess(..process,"javaw.exe",...);	
	};
	popenProcess = function(...){
		return __openProcess(..process.popen,"java.exe",...);	
	};
	runtimeVersion = function(){
		var prcs = popenProcess("-version");
		if(prcs) return prcs.readAll();	
	};
	compilerVersion = function(){
		var prcs = compile("-version");
		if(prcs) return prcs.readAll("[\d._]+\d");	
	};
	compile = function(filepath,...){
		var args = ..string.cmdline.arguments(...);
		..table.push(args, "-classpath",getClassPathCommand( "." ) );
		if(self.encoding){
			..table.push(args,"-encoding",self.encoding,"-J-Dfile.encoding="+self.encoding);
			
		}
		
		if(!filepath) error("请指定参数@1",2)
		if(filepath[1]!='-'#){
			..table.push(args, ..io.localpath(filepath) : filepath )
		}
		else {
			..table.unshift(args,filepath);
		}
		
		var javac = ..java.path.jdkCompiler(); 
		if( javac ){ 
			var prcs,err = ..process.popen(javac,args)
			if( prcs && self.encoding){
				prcs.codepage = ..string.encoding.getCodepage(self.encoding);
			}
			
			return prcs,err;
		}
		else{
			error('找不到javac.exe\n当前系统尚未安装Java开发环境',2)
		}
	};
	__jni_init__ = function(){
		if(JNI_CreateJavaVM) return;   
		var jvmPath = ..java.path.jvm();

		if(!jvmPath)  return; 
		   
		..fsys.setCurDir(..java.path.jvmBin()); 

		var jvm;
		try{ jvm = ..raw.loadDll( jvmPath  ) }
		..fsys.setCurDir("/");
		
		if(!jvm) return; 		

		JNI_GetDefaultJavaVMInitArgs = jvm.api("JNI_GetDefaultJavaVMInitArgs","int(struct &args)" )
		JNI_CreateJavaVM = jvm.api("JNI_CreateJavaVM","int(pointer &pvm,pointer &penv,struct args)" )
		JNI_GetCreatedJavaVMs = jvm.api("JNI_GetCreatedJavaVMs","int(pointer &pvm,int size,int & sizeout)" )
		
			
		return true;
	}
	
	class InitArgs {
    	int version;
		int nOptions;
    	pointer options;
    	BYTE ignoreUnrecognized;
	};
	
	class VmOption {
		ctor(str,extra){
			this.optionString = str;
			this.extraInfo = extra;
		}
    	string optionString;
    	pointer extraInfo;
	}
	
	class JavaVM{ //
    	pointer reserved0;
    	pointer reserved1;
    	pointer reserved2;
		pointer DestroyJavaVM = "int()";
		pointer AttachCurrentThread = "int(pointer &evn,pointer args)";
		pointer DetachCurrentThread = "int()"; 
		pointer GetEnv = "int(pointer &evn,int version)";
		pointer AttachCurrentThreadAsDaemon = "int(pointer &evn,pointer args)"; 
	} 
	
	class JNIEnv { //
		pointer reserved0;
		pointer reserved1;
		pointer reserved2; 
		pointer reserved3;
		pointer GetVersion = "int()";
		pointer DefineClass = "pointer(STRING name,pointer loader,pointer buf,int len)";
		pointer FindClass = "pointer(STRING name)";
		pointer FromReflectedMethod = "pointer(POINTER method)";
		pointer FromReflectedField = "pointer(POINTER field)";
		pointer ToReflectedMethod = "pointer(POINTER cls,pointer methodID,BYTE isStatic)";
		pointer GetSuperclass = "pointer(POINTER sub)";
		pointer IsAssignableFrom = "BYTE(POINTER sub,pointer sup)";
		pointer ToReflectedField = "pointer(POINTER cls,pointer fieldID,BYTE isStatic)";
		pointer Throw = "int(POINTER obj)";
		pointer ThrowNew = "int(POINTER clazz,string msg)";
		pointer ExceptionOccurred = "pointer()";
		pointer ExceptionDescribe = "void()";
		pointer ExceptionClear = "void()";
		pointer FatalError = "void(string msg)";
		pointer PushLocalFrame = "int(int capacity)";
		pointer PopLocalFrame = "pointer(POINTER result)";
		pointer NewGlobalRef = "pointer(POINTER lobj)";
		pointer DeleteGlobalRef = "void(POINTER gref)";
		pointer DeleteLocalRef = "void(POINTER obj)";
		pointer IsSameObject = "BYTE(POINTER obj1,pointer obj2)";
		pointer NewLocalRef = "pointer(POINTER ref)";
		pointer EnsureLocalCapacity = "int(int capacity)";
		pointer AllocObject = "pointer(POINTER clazz)";
		pointer NewObject = ""; //= "pointer(POINTER clazz,pointer methodID,...)";
		pointer NewObjectV = "pointer(POINTER clazz,pointer methodID,struct args)";
		pointer NewObjectA =  "pointer(POINTER clazz,pointer methodID,struct args)";
		pointer GetObjectClass = "pointer(POINTER obj)";
		pointer IsInstanceOf = "BYTE(POINTER obj,pointer clazz)";
		pointer GetMethodID = "pointer(POINTER clazz,STRING name,string sig)";
		pointer CallObjectMethod ; //= "pointer(POINTER obj,pointer methodID,...)";
		pointer CallObjectMethodV = "pointer(POINTER obj,pointer methodID,struct args)";
		pointer CallObjectMethodA = "pointer(POINTER obj,pointer methodID,struct args)";
		pointer CallBooleanMethod ; //= "BYTE(POINTER obj,pointer methodID,...)";
		pointer CallBooleanMethodV = "BYTE(POINTER obj,pointer methodID,struct args)";
		pointer CallBooleanMethodA = "BYTE(POINTER obj,pointer methodID,struct args)";
		pointer CallByteMethod ; //= "byte(POINTER obj,pointer methodID,...)";
		pointer CallByteMethodV = "byte(POINTER obj,pointer methodID,struct args)";
		pointer CallByteMethodA = "byte(POINTER obj,pointer methodID,struct args)";
		pointer CallCharMethod ; //= "WORD(POINTER obj,pointer methodID,...)";
		pointer CallCharMethodV = "WORD(POINTER obj,pointer methodID,struct args)";
		pointer CallCharMethodA = "WORD(POINTER obj,pointer methodID,struct args)";
		pointer CallShortMethod ; //= "BYTE(POINTER obj,pointer methodID,...)";
		pointer CallShortMethodV = "BYTE(POINTER obj,pointer methodID,struct args)";
		pointer CallShortMethodA = "BYTE(POINTER obj,pointer methodID,struct args)";
		pointer CallIntMethod ; //= "int(POINTER obj,pointer methodID,...)";
		pointer CallIntMethodV = "int(POINTER obj,pointer methodID,struct args)";
		pointer CallIntMethodA = "int(POINTER obj,pointer methodID,struct args)";
		pointer CallLongMethod ; //= "long(POINTER obj,pointer methodID,...)";
		pointer CallLongMethodV = "long(POINTER obj,pointer methodID,struct args)";
		pointer CallLongMethodA = "long(POINTER obj,pointer methodID,struct args)";
		pointer CallFloatMethod ; //= "float(POINTER obj,pointer methodID,...)";
		pointer CallFloatMethodV = "float(POINTER obj,pointer methodID,struct args)";
		pointer CallFloatMethodA = "float(POINTER obj,pointer methodID,struct args)";
		pointer CallDoubleMethod ; //= "double(POINTER obj,pointer methodID,...)";
		pointer CallDoubleMethodV = "double(POINTER obj,pointer methodID,struct args)";
		pointer CallDoubleMethodA = "double(POINTER obj,pointer methodID,struct args)";
		pointer CallVoidMethod ; //= "void(POINTER obj,pointer methodID,...)";
		pointer CallVoidMethodV = "void(POINTER obj,pointer methodID,struct args)";
		pointer CallVoidMethodA = "void(POINTER obj,pointer methodID,struct args)";
		pointer CallNonvirtualObjectMethod ; //= "pointer(POINTER obj,pointer clazz,pointer methodID,...)";
		pointer CallNonvirtualObjectMethodV = "pointer(POINTER obj,pointer clazz,pointer methodID,struct args)";
		pointer CallNonvirtualObjectMethodA = "pointer(POINTER obj,pointer clazz,pointer methodID,struct args)";
		pointer CallNonvirtualBooleanMethod ; //= "BYTE(POINTER obj,pointer clazz,pointer methodID,...)";
		pointer CallNonvirtualBooleanMethodV = "BYTE(POINTER obj,pointer clazz,pointer methodID,struct args)";
		pointer CallNonvirtualBooleanMethodA = "BYTE(POINTER obj,pointer clazz,pointer methodID,struct args)";
		pointer CallNonvirtualByteMethod ; //= "byte(POINTER obj,pointer clazz,pointer methodID,...)";
		pointer CallNonvirtualByteMethodV = "byte(POINTER obj,pointer clazz,pointer methodID,struct args)";
		pointer CallNonvirtualByteMethodA = "byte(POINTER obj,pointer clazz,pointer methodID,struct args)";
		pointer CallNonvirtualCharMethod ; //= "WORD(POINTER obj,pointer clazz,pointer methodID,...)";
		pointer CallNonvirtualCharMethodV = "WORD(POINTER obj,pointer clazz,pointer methodID,struct args)";
		pointer CallNonvirtualCharMethodA = "WORD(POINTER obj,pointer clazz,pointer methodID,struct args)";
		pointer CallNonvirtualShortMethod ; //= "BYTE(POINTER obj,pointer clazz,pointer methodID,...)";
		pointer CallNonvirtualShortMethodV = "BYTE(POINTER obj,pointer clazz,pointer methodID,struct args)";
		pointer CallNonvirtualShortMethodA = "BYTE(POINTER obj,pointer clazz,pointer methodID,struct args)";
		pointer CallNonvirtualIntMethod ; //= "int(POINTER obj,pointer clazz,pointer methodID,...)";
		pointer CallNonvirtualIntMethodV = "int(POINTER obj,pointer clazz,pointer methodID,struct args)";
		pointer CallNonvirtualIntMethodA = "int(POINTER obj,pointer clazz,pointer methodID,struct args)";
		pointer CallNonvirtualLongMethod ; //= "long(POINTER obj,pointer clazz,pointer methodID,...)";
		pointer CallNonvirtualLongMethodV = "long(POINTER obj,pointer clazz,pointer methodID,struct args)";
		pointer CallNonvirtualLongMethodA = "long(POINTER obj,pointer clazz,pointer methodID,struct args)";
		pointer CallNonvirtualFloatMethod ; //= "float(POINTER obj,pointer clazz,pointer methodID,...)";
		pointer CallNonvirtualFloatMethodV = "float(POINTER obj,pointer clazz,pointer methodID,struct args)";
		pointer CallNonvirtualFloatMethodA = "float(POINTER obj,pointer clazz,pointer methodID,struct args)";
		pointer CallNonvirtualDoubleMethod ; //= "double(POINTER obj,pointer clazz,pointer methodID,...)";
		pointer CallNonvirtualDoubleMethodV = "double(POINTER obj,pointer clazz,pointer methodID,struct args)";
		pointer CallNonvirtualDoubleMethodA = "double(POINTER obj,pointer clazz,pointer methodID,struct args)";
		pointer CallNonvirtualVoidMethod ; //= "void(POINTER obj,pointer clazz,pointer methodID,...)";
		pointer CallNonvirtualVoidMethodV = "void(POINTER obj,pointer clazz,pointer methodID,struct args)";
		pointer CallNonvirtualVoidMethodA = "void(POINTER obj,pointer clazz,pointer methodID,struct args)";
		pointer GetFieldID = "pointer(POINTER clazz,STRING name,string sig)";
		pointer GetObjectField = "pointer(POINTER obj,pointer fieldID)";
		pointer GetBooleanField = "BYTE(POINTER obj,pointer fieldID)";
		pointer GetByteField = "byte(POINTER obj,pointer fieldID)";
		pointer GetCharField = "WORD(POINTER obj,pointer fieldID)";
		pointer GetShortField = "BYTE(POINTER obj,pointer fieldID)";
		pointer GetIntField = "int(POINTER obj,pointer fieldID)";
		pointer GetLongField = "long(POINTER obj,pointer fieldID)";
		pointer GetFloatField = "float(POINTER obj,pointer fieldID)";
		pointer GetDoubleField = "double(POINTER obj,pointer fieldID)";
		pointer SetObjectField = "void(POINTER obj,pointer fieldID,pointer val)";
		pointer SetBooleanField = "void(POINTER obj,pointer fieldID,BYTE val)";
		pointer SetByteField = "void(POINTER obj,pointer fieldID,byte val)";
		pointer SetCharField = "void(POINTER obj,pointer fieldID,WORD val)";
		pointer SetShortField = "void(POINTER obj,pointer fieldID,BYTE val)";
		pointer SetIntField = "void(POINTER obj,pointer fieldID,int val)";
		pointer SetLongField = "void(POINTER obj,pointer fieldID,long val)";
		pointer SetFloatField = "void(POINTER obj,pointer fieldID,float val)";
		pointer SetDoubleField = "void(POINTER obj,pointer fieldID,double val)";
		pointer GetStaticMethodID = "pointer(POINTER clazz,STRING name,string sig)";
		pointer CallStaticObjectMethod ; //= "pointer(POINTER clazz,pointer methodID,...)";
		pointer CallStaticObjectMethodV = "pointer(POINTER clazz,pointer methodID,struct args)";
		pointer CallStaticObjectMethodA = "pointer(POINTER clazz,pointer methodID,struct jvalue)";
		pointer CallStaticBooleanMethod ; //= "BYTE(POINTER clazz,pointer methodID,...)";
		pointer CallStaticBooleanMethodV = "BYTE(POINTER clazz,pointer methodID,struct args)";
		pointer CallStaticBooleanMethodA = "BYTE(POINTER clazz,pointer methodID,struct jvalue)";
		pointer CallStaticByteMethod ; //= "byte(POINTER clazz,pointer methodID,...)";
		pointer CallStaticByteMethodV = "byte(POINTER clazz,pointer methodID,struct args)";
		pointer CallStaticByteMethodA = "byte(POINTER clazz,pointer methodID,struct jvalue)";
		pointer CallStaticCharMethod ; //= "WORD(POINTER clazz,pointer methodID,...)";
		pointer CallStaticCharMethodV = "WORD(POINTER clazz,pointer methodID,struct args)";
		pointer CallStaticCharMethodA = "WORD(POINTER clazz,pointer methodID,struct jvalue)";
		pointer CallStaticShortMethod ; //= "BYTE(POINTER clazz,pointer methodID,...)";
		pointer CallStaticShortMethodV = "BYTE(POINTER clazz,pointer methodID,struct  args)";
		pointer CallStaticShortMethodA = "BYTE(POINTER clazz,pointer methodID,struct jvalue)";
		pointer CallStaticIntMethod ; //= "int(POINTER clazz,pointer methodID,...)";
		pointer CallStaticIntMethodV = "int(POINTER clazz,pointer methodID,struct args)";
		pointer CallStaticIntMethodA = "int(POINTER clazz,pointer methodID,struct jvalue)";
		pointer CallStaticLongMethod ; //= "long(POINTER clazz,pointer methodID,...)";
		pointer CallStaticLongMethodV = "long(POINTER clazz,pointer methodID,struct args)";
		pointer CallStaticLongMethodA = "long(POINTER clazz,pointer methodID,struct jvalue)";
		pointer CallStaticFloatMethod ; //= "float(POINTER clazz,pointer methodID,...)";
		pointer CallStaticFloatMethodV = "float(POINTER clazz,pointer methodID,struct args)";
		pointer CallStaticFloatMethodA = "float(POINTER clazz,pointer methodID,struct jvalue)";
		pointer CallStaticDoubleMethod ; //= "double(POINTER clazz,pointer methodID,...)";
		pointer CallStaticDoubleMethodV = "double(POINTER clazz,pointer methodID,struct args)";
		pointer CallStaticDoubleMethodA = "double(POINTER clazz,pointer methodID,struct jvalue)";
		pointer CallStaticVoidMethod ; //= "void(POINTER cls,pointer methodID,...)";
		pointer CallStaticVoidMethodV = "void(POINTER cls,pointer methodID,struct args)";
		pointer CallStaticVoidMethodA = "void(POINTER cls,pointer methodID,struct args)";
		pointer GetStaticFieldID = "pointer(POINTER clazz,STRING name,string sig)";
		pointer GetStaticObjectField = "pointer(POINTER clazz,pointer fieldID)";
		pointer GetStaticBooleanField = "BYTE(POINTER clazz,pointer fieldID)";
		pointer GetStaticByteField = "byte(POINTER clazz,pointer fieldID)";
		pointer GetStaticCharField = "WORD(POINTER clazz,pointer fieldID)";
		pointer GetStaticShortField = "BYTE(POINTER clazz,pointer fieldID)";
		pointer GetStaticIntField = "int(POINTER clazz,pointer fieldID)";
		pointer GetStaticLongField = "long(POINTER clazz,pointer fieldID)";
		pointer GetStaticFloatField = "float(POINTER clazz,pointer fieldID)";
		pointer GetStaticDoubleField = "double(POINTER clazz,pointer fieldID)";
		pointer SetStaticObjectField = "void(POINTER clazz,pointer fieldID,pointer value)";
		pointer SetStaticBooleanField = "void(POINTER clazz,pointer fieldID,BYTE value)";
		pointer SetStaticByteField = "void(POINTER clazz,pointer fieldID,byte value)";
		pointer SetStaticCharField = "void(POINTER clazz,pointer fieldID,WORD value)";
		pointer SetStaticShortField = "void(POINTER clazz,pointer fieldID,BYTE value)";
		pointer SetStaticIntField = "void(POINTER clazz,pointer fieldID,int value)";
		pointer SetStaticLongField = "void(POINTER clazz,pointer fieldID,long value)";
		pointer SetStaticFloatField = "void(POINTER clazz,pointer fieldID,float value)";
		pointer SetStaticDoubleField = "void(POINTER clazz,pointer fieldID,double value)";
		pointer NewString = "pointer (POINTER unicode,int len)";
		pointer GetStringLength = "int(POINTER  str)";
		pointer GetStringChars = "pointer(POINTER  str,BYTE &isCopy)";
		pointer ReleaseStringChars = "void(POINTER  str,pointer chars)";
		pointer NewStringUTF = "pointer (string utf)";
		pointer GetStringUTFLength = "int(POINTER  str)";
		pointer GetStringUTFChars = "pointer (POINTER  str,BYTE &isCopy)";
		pointer ReleaseStringUTFChars = "void(POINTER  str,pointer  chars)";
		pointer GetArrayLength = "int(POINTER array)";
		pointer NewObjectArray = "pointer(int len,pointer clazz,pointer init)";
		pointer GetObjectArrayElement = "pointer(POINTER array,int index)";
		pointer SetObjectArrayElement = "void(POINTER array,int index,pointer val)";
		pointer NewBooleanArray = "pointer(int len)";
		pointer NewByteArray = "pointer(int len)";
		pointer NewCharArray = "pointer(int len)";
		pointer NewShortArray = "pointer(int len)";
		pointer NewIntArray = "pointer(int len)";
		pointer NewLongArray = "pointer(int len)";
		pointer NewFloatArray = "pointer(int len)";
		pointer NewDoubleArray = "pointer(int len)"; 
		pointer GetBooleanArrayElements = "pointer(POINTER array,BYTE &isCopy)";
		pointer GetByteArrayElements = "pointer(POINTER array,BYTE &isCopy)";
		pointer GetCharArrayElements = "pointer(POINTER array,BYTE &isCopy)";
		pointer GetShortArrayElements = "pointer(POINTER array,BYTE &isCopy)";
		pointer GetIntArrayElements = "pointer(POINTER array,BYTE &isCopy)";
		pointer GetLongArrayElements = "pointer(POINTER array,BYTE &isCopy)";
		pointer GetFloatArrayElements = "pointer(POINTER array,BYTE &isCopy)";
		pointer GetDoubleArrayElements = "pointer(POINTER array,BYTE &isCopy)";
		pointer ReleaseBooleanArrayElements = "void(POINTER array,pointer elems,int mode)";
		pointer ReleaseByteArrayElements = "void(POINTER array,pointer elems,int mode)";
		pointer ReleaseCharArrayElements = "void(POINTER array,pointer elems,int mode)";
		pointer ReleaseShortArrayElements = "void(POINTER array,pointer elems,int mode)";
		pointer ReleaseIntArrayElements = "void(POINTER array,pointer elems,int mode)";
		pointer ReleaseLongArrayElements = "void(POINTER array,pointer elems,int mode)";
		pointer ReleaseFloatArrayElements = "void(POINTER array,pointer elems,int mode)";
		pointer ReleaseDoubleArrayElements = "void(POINTER array,pointer elems,int mode)"; 
		pointer GetBooleanArrayRegion = "void(POINTER array,int start,int l,struct &arrbuf)";
		pointer GetByteArrayRegion = "void(POINTER array,int start,int len,struct &arrbuf)";
		pointer GetCharArrayRegion = "void(POINTER array,int start,int len,struct &arrbuf)";
		pointer GetShortArrayRegion = "void(POINTER array,int start,int len,struct &arrbuf)";
		pointer GetIntArrayRegion = "void(POINTER array,int start,int len,struct &arrbuf)";
		pointer GetLongArrayRegion = "void(POINTER array,int start,int len,struct &arrbuf)";
		pointer GetFloatArrayRegion = "void(POINTER array,int start,int len,struct &arrbuf)";
		pointer GetDoubleArrayRegion = "void(POINTER array,int start,int len,struct &arrbuf)"; 
		pointer SetBooleanArrayRegion = "void(POINTER array,int start,int l,struct buf)";
		pointer SetByteArrayRegion = "void(POINTER array,int start,int len,struct buf)";
		pointer SetCharArrayRegion = "void(POINTER array,int start,int len,struct buf)";
		pointer SetShortArrayRegion = "void(POINTER array,int start,int len,struct buf)";
		pointer SetIntArrayRegion = "void(POINTER array,int start,int len,struct buf)";
		pointer SetLongArrayRegion = "void(POINTER array,int start,int len,struct buf)";
		pointer SetFloatArrayRegion = "void(POINTER array,int start,int len,struct buf)";
		pointer SetDoubleArrayRegion = "void(POINTER array,int start,int len,struct buf)";
		pointer RegisterNatives = "int(POINTER clazz,struct methods,int nMethods)"; 
		pointer UnregisterNatives = "int(POINTER clazz)";
		pointer MonitorEnter = "int(POINTER obj)";
		pointer MonitorExit = "int(POINTER obj)";
		pointer GetJavaVM = "int(pointer &vm)";
		pointer GetStringRegion = "void(POINTER  str,int start,int len,pointer buf)";
		pointer GetStringUTFRegion = "void(POINTER  str,int start,int len,pointer buf)";
		pointer GetPrimitiveArrayCritical = "pointer (POINTER array,BYTE &isCopy)";
		pointer ReleasePrimitiveArrayCritical = "void(POINTER array,pointer carray,int mode)";
		pointer GetStringCritical = "pointer (POINTER  string,BYTE &isCopy)";
		pointer ReleaseStringCritical = "void(POINTER  string,pointer cstring)";
		pointer NewWeakGlobalRef = "pointer(POINTER obj)";
		pointer DeleteWeakGlobalRef = "void(POINTER ref)";
		pointer ExceptionCheck = "BYTE()";
		pointer NewDirectByteBuffer = "pointer(POINTER address,long capacity)";
		pointer GetDirectBufferAddress = "pointer(POINTER buf)";
		pointer GetDirectBufferCapacity = "long(POINTER buf)";
		pointer GetObjectRefType = "int(POINTER obj)"
    }
    
    
    var typename_a2j = {
		pointer = "Object";
		BOOL= "Boolean";
		bool= "Boolean";
		BYTE= "Boolean";
		CHAR = "Char";
		char = "Char";
		WORD = "Char";
		SHORT = "Short";
		short = "Short";
		word = "Short";
		int = "Int";
		INT = "Int";
		long = "Long";
		LONG = "Long";
		string = "Object";
		byte = "Byte";
		float = "Float";
		double = "Double";
		void = "Void";
	}
	
	typeNameAardio2Java = function(t){
		if(!#t) return "Void"; 
		if( ..string.find(t,"\;") ) return "Object"; 
		return typename_a2j[t] || "Object"
	} 
}

/**intellisense() 
java( = 创建 JAVA 虚拟机,\n如果未找到可用的 JVM 运行库返回 null\n在每个进程第一次创建JAVA 虚拟机或初始化 JVM 路径之前,\n可调用 java.path.setJreHome 自定义搜索 JVM 的 JRE 运行时目录,\njar包搜索顺序为"\","\java\","~\java",\n可使用 java.addClassPath 函数添加搜索路径
java(.(命令行参数,->->->) = n可指定一个或多个启动命令行参数,\n也可以把多个参数写到一个字符串参数或数组参数里,\n\n参数类似 "-D<propertyName>=value"\n在 JAVA 中可以使用 System.getProperty("propertyName") 得到value的值\n\n对于每个打开的进程,JAVA虚拟机仅创建一次实例,\n因此所有参数、搜索路径等仅在首次创建虚拟机时生效
java() = !java.
java.encoding = 指定默认编码,\n默认值为 "utf-8",\nUTF-8 目前是最好也是最通用的设置,\n最好不要改也不必要改
java.openProcess(.("-jar","命令行参数", ->->-> ) = 创建Java窗口应用程序返回process进程对象\n命令行参数可以是数组或任意个文本参数,\n如果命令行参数有多个,则包含空格的参数添加必要的双引号和转义,\n如果参数@1是数组,\n参数@2可指定 process.STARTUPINFO 结构体或部分字段,\n规则考 process 构造函数
java.openProcess() = !process.
java.popenProcess(.("-jar","命令行参数", ->->-> ) = 创建Java控制台应用程序返回process.popen对象\n命令行参数可以是数组或任意个文本参数,\n如果命令行参数有多个,则包含空格的参数添加必要的双引号和转义,\n如果参数@1是数组,\n参数@2可指定 process.STARTUPINFO 结构体或部分字段,\n规则考 process 构造函数
java.popenProcess() = !process_popen.
java.compile(.("java源文件路径") = 编译java源文件\n该函数需要系统安装JDK,可事先设置JAVA_HOME环境变量手动指定JDK位置\n注意如果aardio自带了jre版本必须与JDK一致,不然java程序编译后可能无法运行
java.compile() = !process_popen.
java.addClassPath(__) = 添加一个或多个查找类的根目录\n添加该目录时将自动添加该目录下已存在的 *.jar 文件\n子目录下的jar文件将被忽略\n注意:必须在进程首次创建 Java 虚拟机之前调用该函数
java.addLibPath(__) = 添加一个或多个目录\nJava中调用System.loadLibrary()时将在指定的目录查找DLL组件
java.version = JVM 虚拟机接口版本,\n在进程首次创建虚拟机以前用于指定最低兼容版本\n默认会设为 0x10006/*_JNI_VERSION_1_6*/
!java.version =  JVM 虚拟机接口版本,\nJava 8 的接口版本为 0x10008/*_JNI_VERSION_1_8*/,\n目前 Java 10+ 的接口版本号都是 0xa0000/*JNI_VERSION_10*/
!java.__isMainThread = 仅第一次创建java虚拟机时该值为true,\n随后创建的虚拟机都会返回false
!java.addClassLoaderUrl( = 添加类搜索目录到 CLASSPATH,\n此函数仅支持Jav6~Java8\nJava9 开始不再支持,可以改用 java.addClassPath,\n但 java.addClassPath 仅支持 ANSI编码路径,\naddClassLoaderUrl 函数支持 UTF-8 编码路径
!java.addClassLoaderUrl(.("类搜索路径") = 添加jar包或文件目录到 CLASSPATH,\nJava 在 CLASSPATH 指定的目录或 jar 中搜索类,\n参数可以是一个数组,也可以是多个路径参数
!java.import(.("类名","类文件路径") = 加载指定的类\n可选用参数@2指定类文件路径、或者自内存文件加载类\n如果类不存在或加载失败返回null空值 - 不会抛出异常
!java.exceptionClear() = 该函数如果检测到抛出的异常,并清除异常返回true\n如果未检测到异常返回空值
!java.array("int",__) = 将一个或多个基本类型转换为java数组对象\n传入参数也可以是一个table类型字符串数组
!java.stringArray(__) = 将一个或多个字符串转换为java字符串数组\n传入参数也可以是一个table类型字符串数组
!java.string(__) = 将aardio字符串转换为java字符串对象\n返回对象指针
!java.double(__) = 创建64位浮点数值-返回Java对象
!java.float(__) = 创建32位浮点数值-返回Java对象
!java.char(__) = 创建8位整型数值-返回Java对象
!java.short(__) = 创建16位整型数值-返回Java对象
!java.int(__) = 创建32位整型数值-返回Java对象
!java.long(__) = 创建64位整型数值-返回Java对象
!java.boolean(__) = 创建布尔值-返回Java对象
!java.parseString(__) = 将Java字符串转换为aardio字符串\n注意:该函数会销毁传入的java对象指针
!java.parseStringArray(.(java数组) = 将Java对象指针转换为aardio数组对象\n注意:该函数会销毁传入的java对象指针
!java.parseArray(.("int",java数组)  = 将Java对象指针转换为aardio数组对象,参数一指定数组元素数据类型\n注意:该函数会销毁传入的java对象指针
!java.invokeMethod(.(类或对象,其他调用参数->->->) = 调用Java函数,支持多个参数\n对于数值类型,aardio将会自动检测适用的数值类型\n也可以调用java.int,java.short,java.char,java.long等函数显式的声明数值类型
!java.interop = aardio.interopServices.utility类
!java.fieldExists(.(java对象,"字段名") = 返回是否存在指定字段名
!java.getFieldValue(.(java对象,"字段名") = 返回字段值
!java.setFieldValue(.(java对象,"字段名",字段值) = 修改字段值
!java.createInstance(.(java类对象,->->->) = 调用构造函数创建对象
!java.objectIsNumber(__) = 返回参数指定的java对象是否数值
!java.objectIsString(__) = 返回参数指定的java对象是否字符串
!java.object2Number(__) = java数值对象转换为aardio数值
!java.object2String(__) = java字等串对象转换为aardio字符串
!java.reopen("setErr","conerr$") = 重定向错误输出到控制台
!java.reopen("setOut","conout$") = 重定向标准输出到控制台,\n如果在创建 Java 虚拟机以后打开控制台,\n需要调用此函数才能在控制台看到 Java 的标准输出
!java.import() = !stdJavaClass.
!stdJavaClass.getField(.("字段名","int") = 参数@2指定字段类型声明\n与函数原型使用的语法一致
!stdJavaClass.registerNative(函数,函数名,签名) = @.registerNative(\n	function(env,jobject,jstring){\n		var str = owner.parseString(jstring)\n		\n		return owner.string( func() )\n	},"__/*函数名*/","string(string)"\n)
!stdJavaClass.unregisterNatives() = 注销所有注册到Java类中的函数
!stdJavaClass.free(.("字段名","int") = 参数@2指定字段类型声明\n与函数原型使用的语法一致
!stdJavaClass.createInstance(.(->->->) = 使用Java调用构造函数创建对象\n不限制参数个数以及类型,\n允许以类名本身替代此函数
!stdJavaClass.createInstanceEx(.("void()"，->->->) = 使用JNI调用构造函数创建对象\n参数最多只能是一个参数,或者一个参数数组,\n用户应使用createInstance，该函数不限制参数个数以及类型
!stdJavaClass.createInstanceEx() = !stdJavaObject.
!stdJavaClass() = !stdJavaObject.
!stdJavaObject.getMethod(.("函数名","int(int)") = 返回对象的成员函数\n,注意Java区分大小写，参数只能指定单个参数或数组类型,\n如果需要使用多个参数或动态参数，请直接使用 对象.函数名 获取函数\n注意返回的是原生函数,调用时数值、布尔值不可以使用Java对象
!stdJavaObject.getMethod(.("函数名") = 返回对象的成员函数\n,注意Java区分大小写，返回的函数支持任意个数参数\n注意无论Java对象是否存在该函数都会返回一个函数对象
!stdJavaObject.getField("字段名__","int") = 第二个参数指定字段类型声明\n与函数原型使用的语法一致
_JNI_VERSION_1_1=@0x10001/*_JNI_VERSION_1_1*/
_JNI_VERSION_1_2=@0x10002/*_JNI_VERSION_1_2*/
_JNI_VERSION_1_4=@0x10004/*_JNI_VERSION_1_4*/
_JNI_VERSION_1_6=@0x10006/*_JNI_VERSION_1_6*/
_JNI_VERSION_1_7=@0x10007/*_JNI_VERSION_1_7*/
_JNI_VERSION_1_8=@0x10008/*_JNI_VERSION_1_8*/
_JNI_VERSION_9=@0x90000/*_JNI_VERSION_9*/
_JNI_VERSION_10=@0xA0000/*_JNI_VERSION_10*/
_JNI_FALSE = @0/*_JNI_FALSE*/
_JNI_TRUE = @1/*_JNI_TRUE*/
end intellisense**/