//struct 静态结构体
namespace raw

class struct {
	ctor( cls,ptr ) {{ 
		var clsType = type(cls);
		if(!ptr){ 
			if( clsType == "class" ){
				return class {
					ctor( ... ){ 
						return ..raw.struct( cls( ... ) );
					};
				}; 
					
			}
			elseif(cls[["_struct"]]){ 
				ptr = ..raw.buffer(cls)
			} 
		}
		
		if(ptr){
			var ptrType = type(ptr);
			if( ptrType!==type.pointer && ptrType!==type.buffer ){
				error("参数@2类型错误",2)
			} 
			
			if( clsType = "class"){
				this[["_structObject"]] = cls()
			}
			else {
				this[["_structObject"]] = ..table.assign({},cls);
			}
			
			var t,n = ..string.match(this[["_structObject"]]._struct,"(\a+)\s+([^,\[\s]+)\[");
			if(t && n){
				this[["_arrayValue"]] = {_struct = t + " v";[n]=this[["_structObject"]][n][[1]]}
			}
			
			this[["_structPointer"]] = ptr;
			this@ = _meta;
			return this;
		} 
	}};  
}
	
namespace struct{
	var convert = ..raw.convert;
	var copy = ..raw.copy;
	
	_meta = {
		_topointer = function(){  
			return owner[["_structPointer"]]; 
		}
		_call = function(...){
			var obj = ..table.assign({},owner[["_structObject"]],...); 
			return ..raw.struct(obj,..raw.buffer(obj));
		} 
		_serialize = function(kernelCall){
			if(kernelCall) {
				return ..string.format("global.import('raw.struct') : raw.struct(%s,topointer(0x%p))"
					,..table.tostring(owner[["_structObject"]]),..raw.toPointer(owner[["_structPointer"]]));
			}
			else {
				return ..table.tostring(owner[["_structObject"]]);
			}
		}
		_get = function(k){ 
			var t = type(k);
			if( t === "number" ){
				if(owner[["_arrayValue"]]){
					convert(owner[["_structPointer"]],owner[["_arrayValue"]],,k-1);
					return owner[["_arrayValue"]].v;
				} 
				return;
			}
			else if(t!=="string") return;
			
			var struct = owner[["_structObject"]]; 
			convert(owner[["_structPointer"]],struct);
			
			return struct[k];
		}
		_set = function( k, v ){ 
			var t = type(k);
			if( t === "number" ){ 
				if(owner[["_arrayValue"]]){
					owner[["_arrayValue"]].v = v;
					convert(owner[["_arrayValue"]],owner[["_structPointer"]],,k-1); 
				} 
				return;
			}
			else if(t!=="string") return;
			
			if(type(v) === "function"){
				owner[[k]] = v;
				return;
			}
			
			var struct = owner[["_structObject"]]; 
			convert(owner[["_structPointer"]],struct); 
			
			struct[k] = v;
			copy(owner[["_structPointer"]],struct); 
		} 
	} 
} 

/**intellisense()
raw.struct = 创建静态结构体,\naardio 默认使用动态内存结构体在与静态接口交互时动态分配内存指针,\n但静态结构体可以分配固定不变的内存指针\n\n读写静态结构体字段时直接自内存读写\n如果结构体首个成员为静态类型数组,可直接用数值索引读写该数组成员\n\n静态结构体实例对象可作为原型函数调用复制新的静态结构体,\n作为原型函数调用时可接控受任意个自定义返回对象字段值的表参数
raw.struct( = 创建静态结构体\n静态结构体可直接传入其他线程,\n多线程可直接共享同一静态结构体内存指针,\n但必须由创建静态结构体的线程负责维护该结构体的有效生命周期\n多线程读写此静态结构体时不会自动加锁
raw.struct(.(结构体类) = 返回用于创建静态结构体的类对象,\n返回类创建静态结构体时自动分配 buffer 并绑定该 buffer 指针
raw.struct(.(结构体对象) = 创建并返回静态结构体实例,\n返回的静态结构体将自动分配 buffer 并绑定该 buffer 指针
raw.struct(.(结构体类,内存指针) = 创建并返回返回静态结构体实例,并绑定参数@2指定的内存指针,\n参数@1可以是结构体类或结构体实例对象
end intellisense**/